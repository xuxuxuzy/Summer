
题目描述

  一天zzq主持一项游戏，共n位同学，需要两两同学为一组来上台来玩一项游戏。    但是，众所周知，玩游戏的时候，如果两个人的颜值差距>=m，就会互相嫌弃。  
  所以，为了游戏能够好玩。在游戏开始前，zzq已经调查了所有n个同学的颜值。    但是现在问题又来了，zzq想知道，最多能凑出多少组同学一起上台？    需注意一人只能出现在一个组中。 
输入描述:
多组输入
第一行两个正整数n m（n<=1e5,m<=1e9），意义见描述
第二行有n个由空格分开的正整数xi（xi<=1e9），第i个同学的颜值
输出描述:
每一行输出一个数，表示最多能凑出多少组。

首先将所有人的颜值从小到大排序，如果a【1】和a【2】不能组队，那么a【1】肯定和a【3】不能组队。所以第一个人没有必要去找后边的人去组队，因为假设第一个人和第三个人组了队，兴许之后的第四个人就再没有组队的机会了。所以我们直接按照相邻的两个人组队去做即可。
1.实现多组输入 while（cin>>n>>m）
2.在while循环中嵌套for循环n次，依次获取n个学生的颜值，存入数组a[]
3.数组a从小到大排序
4.贪心算法：依次比较相邻两元素之差，如果可组队，数组下标j前进2，组队数+1，否则数组下标j前进1
5.输出组队数
注：多组输入的n、m不同，所以数组a[]的有效长度存在变化，因此将数组a的声明和组对数count的声明及初始化放在while循环中
#include<iostream>
#include<algorithm>
using namespace std;

int main()
{
    int n,m;//n表示人数，m表示颜值差上限
    while(cin>>n>>m)
    {
        int a[n];//存放每个学生的颜值
        int count=0;//表示组队数，初始为0
        //依次获取每个人的颜值
        for (int i = 0; i < n; ++i)
        {
            cin>>a[i];
        }
        //排序
        sort(a,a+n);
        //贪心算法
        for (int j = 0; j < n-1; )
        {
            if(a[j+1]-a[j]<m)//组队成功
            {
                j+=2;
                count++;
            }
            else//组队失败
            {
                j++;
            }

        }
        //输出组队数
        cout<<count<<endl;
    }
    return 0;
}
